#!/usr/bin/env python

import sys, socket, select, time, json, random
from datetime import datetime

# Your ID number
my_id = sys.argv[1]

leader_id = '0001' 

puts = {}
msg_num = 0
queue = []
currentTask = None
curWorking = False

# Our Info
curentTerm = 0
votedFor = None
log = []

commitIndex = 0
lastApplied = 0

# Leader Info
nextIndex = []
matchIndex = []

ackCount = 0
cachedPacket = None
# Election
term = 0
lastLogIndex = 0
lastLogTerm = 0

voted = []


# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0

#TODO: 
# - 

def put(text):
  global curWorking, ackCount, cachedPacket
  #IF we don't have a leader, define one, constant for now
  #text = json.dumps(msg)
  if redirect(text):
    curWorking = False
    return

  else:
    #did not redirect, need to put
    puts[text['key']] = text['value']
    ackCount = 0 
    packet = {"src": my_id, "dst": text['src'], "type": 'append', 'leader': leader_id, 'entries': ['key': text['key'], 'value': text['value']], 'leaderIndex': commitIndex, 'term': term, 'commitIndex': commitIndex, 'prevLogTerm': log[(len(log) - 1]['term']}
    sendAll(packet); 
    src = text['dst']
    dst = text['src']
    cachedPacket = {"src": src, "dst": dst, "leader": leader_id, "type": "ok", "MID": text['MID']}
    #response to client only on quarom sendSimple(packet)
    #TODO: Fix if there is too much data/time usage
    log.append(packet)

def get(text):
 #text = json.dumps(msg)
  if redirect(text):
    return
  else:
    src = text['dst']
    dst = text['src']
    value = ""
    if text['key'] in list(puts.keys()):
      value = puts[text['key']]
      packet = {"src": src, "dst": dst, "leader": leader_id, "type": "ok", "MID": text['MID'], "value": value}
    else:
      print "FAIL @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"
      packet =  {"src": src, "dst": dst, "leader": leader_id, "type": "fail"}
    sendSimple(packet)

def redirect(msg):
  if leader_id == my_id:
    return False
  else:
    src = msg['dst']
    dst = msg['src']
    MID = msg['MID']
    packet = {"src": src, "dst": dst, "leader": leader_id, "type": "redirect", "MID": MID}
    print "REDIRECTING: ##################################################"
    sendSimple(packet)
  return True

def sendSimple(msg):
  global msg_num
  sock.send(json.dumps(msg))
  print "SENDING:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n" + json.dumps(msg, indent=4)
  msg_num = msg_num + 1
  
def sendAll(msg):
	for rid in replica_ids:
		msg['dst'] = rid
		msg['src'] = my_id
		print "SENDING:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \n" + json.dumps(msg, indent=4)
	  	
		sock.send(json.dumps(msg))	 

def sendHeartbeat():
	for rep_id in replica_ids:
		msg = {'src': my_id, 'dst': rep_id, 'leader': leader_id, 'type': 'beat'}
                sock.send(json.dumps(msg))
                print '%s sending a Heartbeat to %s' % (msg['src'], msg['dst'])

def elect():
	global term, votedFor, voted
	term = term + 1
	msg = {"src": my_id, "dst": None, "leader": my_id, "type": "election", "term": term, "lastLogIndex": lastLogIndex, "lastLogTerm": lastLogTerm}	
	sendAll(msg)
	voted.append(my_id)
	votedFor = my_id

def vote(msg):
	global votedFor, term
	v = True
	if msg['term'] <= term:
		v = False
		print ("TOO LATE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")
	else:
		if votedFor == None or votedFor == msg['src']:
			if msg['lastLogIndex'] >= lastLogIndex:
				voteFor = msg['src']
	src = msg['dst']
        dst = msg['src']
        packet = {"src": src, "dst": dst, "leader": dst, "type": "vote", "response": v, "term": msg['term']}
	sendSimple(packet)

def tally(msg):
	global term, votedFor, leader_id
	#Check for right term here
	if not msg['src'] in voted:
		voted.append(msg['src'])
		if len(voted) > len(replica_ids) / 2 and term == msg['term']:
			votedFor = None
			voted = []
			leader_id = my_id
			print "Leader ID :" + str(leader_id)
			#TODO add more later when we implement it
			msg = {'src': my_id, 'dst': None, 'leader': leader_id, 'term': term, 'type': 'hello'}
			sendAll(msg)
			sendHeartbeat()

def yes_sir(msg):
	global leader_id, votedFor, term
	leader_id = msg['leader']
	votedFor = None
	term = msg['term']
	#Data validation here


def appendCheck(msg):
  global term, commitIndex
  v = False
  if len(log) < msg['commitIndex'] or msg['term'] < term or log[msg['commitIndex']]['term'] not equal msg['prevLogTerm']):
    v = False
  else:
    v = True
    if len(log) > msg['commitIndex']:
      log = log[:msg['commitIndex'] + 1]
    log.append(msg)
    for ents in msg['entries']:
      puts[ents['key']] = ents['value']
      #may need to funk with the math for blocking entries
    commitIndex = min(msg['commitIndex'], len(log)-1) #both leader and reciever do a -1 on the commit index, may cause off by 1's check!!!!)
  packet = {"src": my_id, "dst": msg['src'], "leader": leader, "type": "appendResponse",'commitIndex': msg['commitIndex'],  "response": v, "term": term]}
  sendSimple(packet)

def handleAppend(msg):
  global ackCount
  if msg['response'] == True:
    if msg['src'] not in ackCount:
      ackCount.append(msg['src']
      if len(ackCount) > replica_ids / 2 and msg['commitIndex'] == commitIndex:
	curWorking = False
        simpleSend(cachedPacket)
  #FIGURE OUT WHAT FALSE DOES, nextIndex & matchIndex used here

waitTime = random.uniform(150,300)
print "Wait time for " + str(my_id) + " is :" + str(waitTime)
clock = datetime.now().second * 1000 + datetime.now().microsecond / 1000
last = clock
print "Clock: " + str(clock)

while True:
	ready = select.select([sock], [], [], 0.1)[0]
	
	if sock in ready:
		msg_raw = sock.recv(32768)

		if len(msg_raw) == 0: continue
		msg = json.loads(msg_raw)
		queue.append(msg)
	if not curWorking and len(queue) > 0
	  	curWorking = True
		currentTask = queue[0]
		queue = queue[1:]
		msg = currentTask
		# For now, ignore get() and put() from clients
		if msg['type'] in ['get', 'put', 'election', 'vote', 'hello', 'beat', 'append', 'appendResponse']:
                        if msg['type'] == 'get':
			  get(msg)
			  curWorking = False
			if msg['type'] == 'put':
			  put(msg)
			if msg['type'] == 'election':
			  vote(msg)
			if msg['type'] == 'vote':
			  tally(msg)
			if msg['type'] == 'hello':
			  yes_sir(msg)
			if msg['type' = 'append':
			  appendCheck(msg)
			if msg['type'] = 'appendResponse':
			  handleAppend(msg)
			if msg['type'] == 'beat':
			  print '%s received a Heartbeat from %s' % (msg['dst'], msg['src'])
			  last = datetime.now().second * 1000 + datetime.now().microsecond / 1000
			#print json.dumps(msg, indent=4)
	clock = datetime.now().second * 1000 + datetime.now().microsecond / 1000
	if clock-last > 70 and leader_id == my_id:
		sendHeartbeat()
		last=clock
	
	if clock-last > waitTime and leader_id != my_id and votedFor == None:
		print "Voted for: " + str(votedFor)
		print "Time diff: " + str(clock-last)
		clock = datetime.now().second * 1000 + datetime.now().microsecond / 1000
		last = clock
		elect()
	#print "PUTS SIZE: " + str(len(list(puts.keys()))) + "\n NUM MESSAGES: " + str(msg_num)
print "Length of puts: " + str(len(puts)) 
